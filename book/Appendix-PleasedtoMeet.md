# Pleased to Meet Your Acquaintance

A long time ago, on a night just like tonight...

## Journey

My journey through programming has been an interesting one. I would never say that I am an expert, by any means, but I certainly have tasted the fine fruits of many paradigms and systems.

I started with Object Orientation as many of you have, no doubt. C# gave way to Java gave way to Javascript.

Naturally, with Javascript I became fascinated by this concept of "first class functions". Javascript gave way to Haskell. Why the jump to Haskell? I'm a bit of an extremist. At times, aren't we all?

I indulged many hours in the pursuit of learning Haskell. Eventually I moved on due to my current employment. Back to Objects with Python.

In my time with Python, I learned a great deal about real world programming. I was enraptured by the tradesman-esque Pythonic ideal of "get things done". Especially so after having my foray into Haskell.

I decided to do some additional exploration into the world of scripting languages similar to Python. I learned about Ruby and I learned about Perl.

I often read about the large influence that Perl had on both Python and Ruby. I looked into its community and learned about CPAN, regex, and the like.

## Something Amiss

I felt something was missing throughout my time with the "workhorse" family of languages. Haskell, while arcane and unapproachable, left an impression on me. Not so much recursion, and not so much guards, but rather the data abstraction, type system, and pattern matching.

Once you design a program in Haskell, it's hard to go back. Haskell lets you program in a declarative way, rather than an imperative way. It lets you describe your problem domain with such clarity and tersity.

If only I could find a Python-esque language that allowed the same.

## Enlightenment

Three items changed my outlook on programming languages.

- [Types are Like the Weather, Type Systems are Like Weathermen](https://youtu.be/XTl7Jn_kmio)
- [Perl6 Types: Made for Humans](http://blogs.perl.org/users/zoffix_znet/2016/04/perl-6-types-made-for-humans.html)
- [Getting Beyond Static vs Dynamic](https://youtu.be/id4pDstMu1s)

I will grant that I have certainly not given up on languages like Haskell. In fact, I still entertain them quite often. And certainly no other language has had more of an impact on how I write code.

Nevertheless, I was convinced to give Perl6 a try.

## A Note on Objections to Perl

Note that Perl has a reputation for "line noise", having many exceptions to the rule, and having more than one way to do it.

On line noise, I've actually come to enjoy the symbols that Perl6 uses. Going back to a language like Ruby or Elixir or Python feels a bit strange for their lack of such things. Comparatively, I now feel that use of symbols in a programming language can add a nice density of information in a smaller space. One wouldn't say that Chinese is line noise compared to English, for example. So, this most certainly is a matter of preference.

On exceptions to the rule, this is a tricky one, no doubt. Learning Perl6 is a lot like learning a natural language. It is best to see the language in action and to learn from experience. In this way, learning Perl6 is more like learning Spanish. Meanwhile learning Python or Haskell may feel more like learning Esperanto or Lojban, respectively. For example, after coding for a bit with Perl6, I've found that it does feel natural for `$_` to work in some situations while in others you would use `*`. These little quirks are actually quite logical, and can be learned intuitively without even trying.

On "there's more than one way to do it", programming is for humans. Programming a computer is a very difficult thing to do. Thus, generally, humans need abstractions in order to program. The abstractions we use today are not guaranteed to be the best abstractions tomorrow. The flexibility of a language like Perl6 allows you to build amazing abstractions and horrible abstractions. It lets you decide for yourself and your team, which is which.
